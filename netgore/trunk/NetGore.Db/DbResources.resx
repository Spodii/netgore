<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ColumnMetadataCode" xml:space="preserve">
    <value>/// &lt;summary&gt;
/// Contains the metadata for a database column.
/// &lt;/summary&gt;
public class ColumnMetadata
{
    /// &lt;summary&gt;
    /// The comment of the column from the database.
    /// &lt;/summary&gt;
    readonly string _comment;

    /// &lt;summary&gt;
    /// A string containing the database column type.
    /// &lt;/summary&gt;
    readonly string _databaseType;

    /// &lt;summary&gt;
    /// The default value of the database column. Can be null.
    /// &lt;/summary&gt;
    readonly object _defaultValue;

    /// &lt;summary&gt;
    /// If this database column is a foreign key.
    /// &lt;/summary&gt;
    readonly bool _isForeignKey;

    /// &lt;summary&gt;
    /// If this database column is a primary key.
    /// &lt;/summary&gt;
    readonly bool _isPrimaryKey;

    /// &lt;summary&gt;
    /// The name of the column.
    /// &lt;/summary&gt;
    readonly string _name;

    /// &lt;summary&gt;
    /// If this database column's value can be null.
    /// &lt;/summary&gt;
    readonly bool _nullable;

    /// &lt;summary&gt;
    /// The system Type used with this database column.
    /// &lt;/summary&gt;
    readonly Type _type;

    /// &lt;summary&gt;
    /// Gets the database comment of the column from the database.
    /// &lt;/summary&gt;
    public string Comment
    {
        get { return _comment; }
    }

    /// &lt;summary&gt;
    /// Gets a string containing the database column type.
    /// &lt;/summary&gt;
    public string DatabaseType
    {
        get { return _databaseType; }
    }

    /// &lt;summary&gt;
    /// Gets the default value of the database column. Can be null.
    /// &lt;/summary&gt;
    public object DefaultValue
    {
        get { return _defaultValue; }
    }

    /// &lt;summary&gt;
    /// Gets if this database column is a foreign key.
    /// &lt;/summary&gt;
    public bool IsForeignKey
    {
        get { return _isForeignKey; }
    }

    /// &lt;summary&gt;
    /// Gets if this database column is a primary key.
    /// &lt;/summary&gt;
    public bool IsPrimaryKey
    {
        get { return _isPrimaryKey; }
    }

    /// &lt;summary&gt;
    /// Gets the name of the database column.
    /// &lt;/summary&gt;
    public string Name
    {
        get { return _name; }
    }

    /// &lt;summary&gt;
    /// Gets if this database column's value can be null.
    /// &lt;/summary&gt;
    public bool Nullable
    {
        get { return _nullable; }
    }

    /// &lt;summary&gt;
    /// Gets the system Type used with this database column.
    /// &lt;/summary&gt;
    public Type Type
    {
        get { return _type; }
    }

    /// &lt;summary&gt;
    /// ColumnMetadata constructor.
    /// &lt;/summary&gt;
    /// &lt;param name="name"&gt;A string containing the database column type.&lt;/param&gt;
    /// &lt;param name="comment"&gt;The comment of the column from the database.&lt;/param&gt;
    /// &lt;param name="databaseType"&gt;A string containing the database column type.&lt;/param&gt;
    /// &lt;param name="defaultValue"&gt;The default value of the database column. Can be null.&lt;/param&gt;
    /// &lt;param name="type"&gt;The system Type used with this database column.&lt;/param&gt;
    /// &lt;param name="nullable"&gt;If this database column's value can be null.&lt;/param&gt;
    /// &lt;param name="isPrimaryKey"&gt;If this database column is a primary key.&lt;/param&gt;
    /// &lt;param name="isForeignKey"&gt;If this database column is a foreign key.&lt;/param&gt;
    public ColumnMetadata(string name, string comment, string databaseType, object defaultValue, Type type, bool nullable,
                          bool isPrimaryKey, bool isForeignKey)
    {
        _name = name;
        _comment = comment;
        _databaseType = databaseType;
        _defaultValue = defaultValue;
        _type = type;
        _nullable = nullable;
        _isPrimaryKey = isPrimaryKey;
        _isForeignKey = isForeignKey;
    }
}</value>
    <comment>The code template used for building the ColumnMetadata class.</comment>
  </data>
  <data name="ConstEnumDictionaryCode" xml:space="preserve">
    <value>/// &lt;summary&gt;
/// A Dictionary-like lookup table for the Enum values of the type collection `[COLUMNCOLLECTIONNAME]` for the
/// table that this class represents. Majority of the code for this class was automatically generated and
/// only other automatically generated code should be using this class.
/// &lt;/summary&gt;
public class [CLASSNAME] : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt;&gt;, IPersistable
{
    /// &lt;summary&gt;
    /// Name of the node that contains all the values.
    /// &lt;/summary&gt;
    const string _valuesNodeName = "Values";

    /// &lt;summary&gt;
    /// Name of the key for the value's key.
    /// &lt;/summary&gt;
    const string _keyKeyName = "Key";

    /// &lt;summary&gt;
    /// Name of the key for the value's value.
    /// &lt;/summary&gt;
    const string _valueKeyName = "Value";
    
    /// &lt;summary&gt;
    /// Array that takes in the enum's value (casted to an int) as the array index, and spits out the
    /// corresponding index for the instanced &lt;see name="_values"/&gt; array. This allows us to build an array
    /// of values without wasting any indicies even if the defined enum skips values.
    /// &lt;/summary&gt;
    static readonly int[] _enumToValueIndex;

    /// &lt;summary&gt;
    /// Array that takes in the &lt;see cref="_values"/&gt; array index and spits out the enum value that the
    /// index is for. This is to allow for a reverse-lookup on the &lt;see cref="_enumToValueIndex"/&gt;.
    /// &lt;/summary&gt;
    static readonly [KEYTYPE][] _valueIndexToKey;

    /// &lt;summary&gt;
    /// The total number of unique defined enum values. Each instanced &lt;see cref="_values"/&gt; array
    /// will have a length equal to this value.
    /// &lt;/summary&gt;
    static readonly int _numEnumValues;

    /// &lt;summary&gt;
    /// Array containing the actual values. The index of this array is found through the value returned
    /// from the _lookupTable.
    /// &lt;/summary&gt;
    readonly [INVALUETYPE][] _values;

    /// &lt;summary&gt;
    /// Gets the &lt;see cref="Type"/&gt; used internally to store the values. This may or may not be the same as the
    /// type used to expose the values.
    /// &lt;/summary&gt;
    public static Type InternalType { get { return typeof([INVALUETYPE]); } }

    /// &lt;summary&gt;
    /// Initializes the &lt;see cref="[CLASSNAME]"/&gt; class.
    /// &lt;/summary&gt;
    static [CLASSNAME]()
    {
        _valueIndexToKey = EnumHelper&lt;[KEYTYPE]&gt;.Values.ToArray();
        _numEnumValues = _valueIndexToKey.Length;
        _enumToValueIndex = new int[EnumHelper&lt;[KEYTYPE]&gt;.MaxValue + 1];

        for (int i = 0; i &lt; _valueIndexToKey.Length; i++)
        {
            var key = (int)_valueIndexToKey[i];
            _enumToValueIndex[key] = i;
        }
    }
    
    /// &lt;summary&gt;
    /// Initializes a new instance of the &lt;see cref="[CLASSNAME]"/&gt; class.
    /// &lt;/summary&gt;
    public [CLASSNAME]()
    {
        _values = new [INVALUETYPE][_numEnumValues];
    }
    
    /// &lt;summary&gt;
    /// Gets or sets an item's value using the &lt;paramref name="key"/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name="key"&gt;The key for the value to get or set.&lt;/param&gt;
    /// &lt;returns&gt;The item's value for the corresponding &lt;paramref name="key"/&gt;.&lt;/returns&gt;
    /// &lt;exception cref="ArgumentOutOfRangeException"&gt;&lt;paramref name="value"/&gt; is less than &lt;see cref="[INVALUETYPE].MinValue"/&gt;
    /// or greater than &lt;see cref="[INVALUETYPE].MaxValue"/&gt;.&lt;/exception&gt;
    public [EXVALUETYPE] this[[KEYTYPE] key]
    {
        get 
        { 
			return ([EXVALUETYPE])_values[_enumToValueIndex[(int)key]]; 
		}
        set 
        {
			if (value &gt; [INVALUETYPE].MaxValue || value &lt; [INVALUETYPE].MinValue)
				throw new ArgumentOutOfRangeException("value", "Value must be between " + [INVALUETYPE].MinValue + " and " + [INVALUETYPE].MaxValue + ".");
				 
			_values[_enumToValueIndex[(int)key]] = ([INVALUETYPE])value; 
		}
    }

    #region IEnumerable&lt;KeyValuePair&lt;[KEYTYPE],[EXVALUETYPE]&gt;&gt; Members

    /// &lt;summary&gt;
    /// Returns an enumerator that iterates through the collection.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// A &lt;see cref="T:System.Collections.Generic.IEnumerator`1"/&gt; that can be used to iterate through the collection.
    /// &lt;/returns&gt;
    public IEnumerator&lt;KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt;&gt; GetEnumerator()
    {
        for (int i = 0; i &lt; _values.Length; i++)
        {
            yield return new KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt;(_valueIndexToKey[i], ([EXVALUETYPE])_values[i]);
        }
    }

    /// &lt;summary&gt;
    /// Returns an enumerator that iterates through a collection.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;
    /// An &lt;see cref="T:System.Collections.IEnumerator"/&gt; object that can be used to iterate through the collection.
    /// &lt;/returns&gt;
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    #endregion

    /// &lt;summary&gt;
    /// Reads the state of the object from an &lt;see cref="IValueReader"/&gt;. Values should be read in the exact
    /// same order as they were written.
    /// &lt;/summary&gt;
    /// &lt;param name="reader"&gt;The &lt;see cref="IValueReader"/&gt; to read the values from.&lt;/param&gt;
    public void ReadState(IValueReader reader)
    {
        // Zero all the existing values
        for (int i = 0; i &lt; _values.Length; i++)
            _values[i] = default([INVALUETYPE]);

        // Read and set the values
        var values = reader.ReadManyNodes&lt;KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt;&gt;(_valuesNodeName, ReadValueHandler);
        foreach (var value in values)
        {
            this[value.Key] = value.Value;
        }
    }

    /// &lt;summary&gt;
    /// Writes the state of the object to an &lt;see cref="IValueWriter"/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name="writer"&gt;The &lt;see cref="IValueWriter"/&gt; to write the values to.&lt;/param&gt;
    public void WriteState(IValueWriter writer)
    {
        writer.WriteManyNodes(_valuesNodeName, this.Where(x =&gt; x.Value != default([EXVALUETYPE])), WriteValueHandler);
    }

    /// &lt;summary&gt;
    /// Reads a &lt;see cref="KeyValuePair{Key, Value}"/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name="reader"&gt;The &lt;see cref="IValueReader"/&gt; to read from.&lt;/param&gt;
    /// &lt;returns&gt;The read &lt;see cref="KeyValuePair{Key, Value}"/&gt;.&lt;/returns&gt;
    static KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt; ReadValueHandler(IValueReader reader)
    {
        var key = reader.ReadEnum&lt;[KEYTYPE]&gt;(_keyKeyName);
        var value = ([EXVALUETYPE])reader.[VALUEREADERREADMETHOD](_valueKeyName);
        return new KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt;(key, value);
    }

    /// &lt;summary&gt;
    /// Writes a &lt;see cref="KeyValuePair{Key, Value}"/&gt;.
    /// &lt;/summary&gt;
    /// &lt;param name="writer"&gt;The &lt;see cref="IValueWriter"/&gt; to write to.&lt;/param&gt;
    /// &lt;param name="value"&gt;The &lt;see cref="KeyValuePair{Key, Value}"/&gt; to write.&lt;/param&gt;
    static void WriteValueHandler(IValueWriter writer, KeyValuePair&lt;[KEYTYPE], [EXVALUETYPE]&gt; value)
    {
        writer.WriteEnum(_keyKeyName, value.Key);
        writer.Write(_valueKeyName, ([INVALUETYPE])value.Value);
    }
}</value>
    <comment>The code template used for building a CostEnumDictionary class.</comment>
  </data>
</root>